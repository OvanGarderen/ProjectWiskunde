\chapter{Fourier}

Bij het analyseren van periodieke functies is de Fourier-transformatie het gereedschap bij uitstek.
Het is een manier om een signaal te karakteriseren aan de hand van een bereik aan frequenties.
Dit maakt het een overtuigende manier om `nette' periodieke functies te beschrijven.
We kunnen de eis van periodiciteit ook loslaten als we naar functies op een interval kijken door dit op te vatten
als \'e\'en fase van een periodieke functie.

Iets concreter kijken we naar functies $f\in L_2([a,b])$.


De basisfuncties waarmee we vervolgens de analyse uitvoeren worden gegeven door de complexe $e$-machten.
\begin{definitie}[Fourierbasis] Bekijk de functieruimte $L_2([a,b])$, we defini\"eren de verzameling $F_{a,b}$ 
door:
\[
  F_{a,b} := \left\{ \phi_k(x) = \tfrac{1}{\sqrt{b-a}} e^{\dpii \cdot k \frac{x-a}{b-a}} \largediv k \in \Z \right\}
\]
We noemen $F_{a,b}$ de Fourierbasis van $L_2([a,b])$
\end{definitie}
Het woord basis is hier met recht gebruikt, het is immers bekend dat de complexe $e$-machten loodrecht staan onder
het inproduct dat we gedefinieerd hebben. Om nu een willekeurige functie te schrijven in deze basis, introduceren
we de Fouriergetransformeerde.
\begin{definitie}[Fouriergetransformeerde]
Zij gegeven een functie $f\in L_2([a,b])$, schrijf dan $\hat f : \Z\to\C$ met entries gedefinieerd volgens:
\[
  \hat f [n] = \frac{1}{\sqrt{b-a}} \cdot \inpr{f}{\phi_n} = \frac{1}{b-a} \int_a^b f(x) \cdot e^{-2 \pi i \cdot k \frac{x-a}{b-a}}\d{x}.
\]
We noemen $\hat f$ de Fouriergetransformeerde van $f$.
\end{definitie}
\begin{definitie}[Inverse Fouriertransformatie]
  Gegeven een Fouriergetransformeerde $\hat f$ van een functie $f \in L_2([a,b])$ is de reconstructie $f^\circ$ van $f$ gegeven door:
  \[
    f^\circ (x) = \sum_{k=-\infty}^\infty \hat f [k] \phi_k(x)
  \]
\end{definitie}

Het kan worden aangetoond dat $f^\circ$ een reconstructie geeft van $f$ die voldoet aan: \cite{fourier-rec} 
\begin{eqnarray}
  \Ldnorm{f-f^\circ}{a,b}=0 \quad\quad \text{wanneer }& f\in L_2([a,b]) \\
  f(x) = f^\circ(x) \quad\quad \text{wanneer }& f \in C^1 
\end{eqnarray}

%-----------------------------------------------------------------------------------------------------------------
\section{De \emph{Discrete Fourier Transform}}
Zoals we gezien hebben in het vorige hoofdstuk kan de Fouriertransformatie gebruikt worden om continue signalen te karakteriseren voor verschillende frequenties. Een groot gebied binnen de signaalanalyse is echter van discrete aard aangezien hier veelal digitale instrumenten worden gebruikt. De toepassingen waarnaar wij op zoek zijn liggen in dit digitale domein (JPEG is een beeldcompressie-algoritme) en dus zal het verslag zich verder afspelen in deze discrete setting.

Om discrete signalen te analyseren lijkt het voor de hand te liggen om een deze als stapfuncties te zien. Een stapfunctie zit immers in $L_2$. De discontinuiteiten van de stapfunctie leiden echter tot ongewenste resultaten, zoals is te zien aan de reconstructie van een blokgolf door middel van Fouriertransformatie. TODO MISCHIEN PLAATJE?
Erger nog, elke eindige som van continue functies is weer continu dus voor een perfecte reconstructie van een discreet signaal is met deze methode altijd een oneindige rij \coefficient en nodig. Bovendien is het moeilijk om uit deze \coefficient en relevante informatie te destilleren over de aard van het signaal.

In plaats van de discrete signalen in te bedden in $L_2$ zullen we een discreet analogon gebruiken voor de Fouriertransformatie.
Hiervoor zullen we de Fourier-basis discretiseren en ons richten op de ruimte $\R^n$.
We veranderen daarvoor de co\"ordinaten naar een discrete $j$ volgens
\[
\frac{x-a}{b-a} \leftrightarrow \frac j n 
\]
Op deze manier zal de discretisatie in de limiet naar het continue geval overgaan. 

\begin{definitie}[Discrete Fourierbasis] Gegeven de ruimte $\C^n$, definieer dan de verzameling
\[
  S_n := \left\{ s_k [j] = e^{\dpii\cdot k j/n } \largediv k,j \in \{1, \ldots, n\} \right\},
\]
als de \emph{discrete Fourierbasis} op deze ruimte met basisvectoren $s_k$.
\end{definitie}
We weten dat de basisvectoren loodrecht staan vanwege de eigenschap:
\[
  \inpr{s_k}{s_j} = 
  \sum_{m=1}^n s_k[m]\cdot \overline{s_j[m]} = 
  \sum_{m=1}^n e^{\dpii\cdot m (k-j)/n} =
  \begin{cases}
    0 \quad \text{als } k\neq j\\
    n \quad \text{als } k = j
  \end{cases}
\]
Vanwege deze eigenschap kunnen we een discreet signaal $x$ schrijven in termen van deze basis door 
een vector van inproducten te defini\"eren.
we noemen $X$ de discrete Fouriergetransformeerde (DFT) met entries:
\[
  X[k] = \tfrac{1}{n} \inpr{x}{s_k} \quad k\in\{1, \ldots ,n\}
\]
Vervolgens hebben we een inverse voor deze operatie die $X$ afbeeldt op $x^\circ$ volgens:
\[
  x[j] = \inpr{X}{s_j^{-1}} \quad j\in \{1, \ldots, n\}
\]
Waarbij we de notatie $s_j^{-1} = (s_j[1]^{-1},...)$ gebruiken.
Volgens de regels van de Lineaire Algebra is dit is een perfecte reconstructie ($x[k] = x^\circ[k]$).

Om de claim te ondersteunen dat de DFT-methode een echte discretisatie is van de continue Fouriertransformatie 
willen we bewijzen dat dit algoritme voor een steeds fijnere selectie van waardes van een functie in de 
limiet hetzelfde resultaat geeft als de continue Fouriertransformatie. 
Zoals gebruikelijk bij het overschakelen van een discrete naar een continue setting, kunnen we dit doen 
door de definitie van de Riemann integraal toe te passen op de sommatie die voor handen ligt.

\begin{stelling}[Limiet van discrete Fourier-transformatie]
  Gegeven een functie $f\in L_2([a,b])$ op het interval $[a,b]$,
  bekijk een discretisatie van $f$ in $n$ gelijke intervallen zodat de discrete $f$ precies 
  de randwaarde waarde van elk interval inneemt.
  Dan geldt dat de discrete Fouriergetransformeerde limiteert naar de algemene Fouriergetransformeerde wanneer $n\to\infty$.
\end{stelling} 
\begin{proof}[Bewijs]
Gegeven een interval $[a,b]$ kunnen we een partitie $P$ maken in $n$ gelijke delen, 
ofwel laat $P=\{a=t_0,t_1,..,t_n=b\}$ met $t_j = a+\tfrac{j(b-a)}{n}$.
We discretiseren onze functie $f$ door uit elk interval $[t_{j-1},t_{j}]$ van de partitie de randwaarde in 
$x_j = t_j$ te selecteren, dus
\[
f[j] = f(x_j) = f(\frac{b-a}{n}j + a)
\]
De DFT van de discrete functie $f[\cdot]$ wordt dan gegeven door:
\[
F[k] = \frac1n\sum_{j=1}^n f[j] \cdot s_k^{-1}[j].
\]
We schrijven dit om in termen van onze non-discrete functie door $x_j\in[a,b]$ 
omschrijven naar zijn discrete tegenhanger en krijgen zo:
\begin{eqnarray*}
  F[k] =& \frac{1}{n} \sum_{j=1}^n f[j]\cdot s_k^{-1}[n\cdot\tfrac{x_j-a}{b-a}] \\
       =& \frac{1}{n} \sum_{j=1}^n f(x_j)\cdot e^{-\dpii \cdot k \tfrac{x_j-a}{b-a}}\\
       =&  \frac{1}{\sqrt{b-a}}\sum_{j=1}^n f(x_j)\cdot \phi^*_k(x_j) \cdot\frac{b-a}{n} 
\end{eqnarray*}
We merken op dat de term $\frac{b-a}{n}$ precies de grootte is van de subintervallen van de partitie interval 
en dat we het geheel omgeschreven hebben in termen van onze continue functies $f$ en $\phi_k$.
Omdat het product $f\cdot\phi_k$ integreerbaar is moet voor elke partitie $P$ met 
waarden in punten $x_j$ uit elk interval deze sommatie convergeren naar de integraal
\[
  \frac{1}{\sqrt{b-a}} \int_{[a,b]} f(x) \phi^*_k(x) \d{x}
\]
wanneer we de maaswijdte ($\tfrac{b-a}{n}$) naar $0$ laten gaan. 
Dit is duidelijk het geval wanneer we de limiet $n\to\infty$ nemen. 
Dus is de DFT een goede discretisatie van de Fouriergetransformeerde. 
\end{proof}
 
Voor de werking van het DFT algoritme als signaalcompressie-algoritme is het van belang dat er een 
inverse algoritme bestaat dat het getransformeerde inputsignaal weer terugtransformeert 
zonder verlies van informatie. We zullen nu bewijzen dat dit mogelijk is door de DFT en iDFT te gebruiken.

%-----------------------------------------------------------------------------------------------------------------
\section{De Fast Fourier Transform}
\label{fft_sec}
De snelheid van het DFT algoritme valt in de praktijk nogal tegen, het nemen van $n$ inproducten over vectoren 
van lengte $n$ heeft namelijk een tijdscomplexiteit van $\O(n^2)$. Dit staat de directe implementatie van de DFT 
voor praktische toepassingen in de weg. Daarom is er een alternatief algoritme, de \emph{Fast Fourier Transform}.  \bigskip

%%%%%
\begin{algo}[Fast Fourier Transform]
Gegeven zij een inputsignaal $x$ van lengte $n=2^m$, dan geeft het algoritme $\FFT$ 
een lijst terug van waardes $X$ van lengte $n=2^m$ als volgt:

Als $m=0$ dan geeft de $\FFT$ de lijst (van \'e\'en element) direct terug:
\[
X = x.
\]
Wanneer $m\neq0$ splitsen we de lijst $x$ op in lijsten $\e,o$ van zijn even en oneven indices:
\eq{
  \e[k]   =& x[2k]   &\quad \text{voor } k < n/2\\
   o[k]   =& x[2k+1] &\quad \text{voor } k < n/2
}
Vervolgens voeren we hierop het $\FFT$ algoritme uit om de volgende lijsten te verkrijgen:
\eq{
  E =& \FFT(\e) \\
  O =& \FFT(o)
}
Hiermee wordt de output van het algoritme geconstrueerd als volgt:
\[
  X[k] = \left\{\begin{array}{llll}
    E[k]         &+& e^{-\dpii k/n}\cdot O[k] &  k< n/2 \\
    E[k-n/2] &-& e^{-\dpii (k-n/2)/n}\cdot O[k-n/2] &  k\geq n/2 
  \end{array}\right.
\]
\end{algo}
%%%%%

Dit is dus een recursief gedefinieerd algoritme dat een signaal meermaals halveert en in zichzelf terugvoert.
Het is gegarandeerd dat dit algoritme afloopt vanwege de conditie op $n=0$ samen met de halvering van de input bij elke stap. Een belangrijke voorwaarde voor de relevantie van de FFT is nu dat het algoritme hetzelfde resultaat geeft als het DFT algoritme en dit zullen we nu dan ook bewijzen. 

\begin{stelling}[]
  Het uitvoeren van het Fast Fourier Transform algoritme op een dataset van lengte $n=2^m$ geeft
  dezelfde getransformeerde als de discrete Fouriertranformatie.
\end{stelling}
\begin{proof}[Bewijs]
We gebruiken hier een inductief bewijs met inductie naar $n$. Onze aanname is dat het FFT-algoritme voor $x$ van lengte $n=2^m$ gelijk is aan de DFT van $x$, ofwel
\eq{
  X[k] = \sum^{n}_{k=1} x[j] \cdot e^{-2\pi i \cdot jk/n}
}
Dit geldt duidelijkerwijs wanneer $m=0$, onze basistap. Hiervoor geldt namelijk:
\eq{
  X[k] = x[k] = x[1] = \sum^{2^0}_{k=1} x[j] \cdot e^{-2\pi i \cdot 1/2^0}
}
Vervolgens passen we inductie toe naar $m$ door onze aanname voor $m-1$ te gebruiken,
we vullen hiermee $E[k]$ en $O[k]$ in de vergelijking voor $X[k]$ in, deze hebben immers lengte $n=2^{m-1}$.
\eq{
  X[k] = \left\{\begin{array}{llll}
    \sum^{n/2}_{j=1} \e[j] 
    \cdot e^{-2\pi i \cdot kj \cdot 2/n} &+& 
    e^{-2\pi i \cdot k/n}
    \sum^{n/2}_{j=1} o[j] 
    \cdot e^{-2\pi i\cdot kj \cdot 2/n} &  k< n/2 \\
    \sum^{n/2}_{j=1} \e[j] 
    \cdot e^{-2\pi i\cdot (k-n/2) j\cdot 2/n} &-& 
    e^{-2\pi i\cdot (k-n/2)/n}
    \sum^{n/2}_{j=1} o[j] \cdot e^{-2\pi i\cdot (k-n/2)j\cdot 2/n} &  k\geq n/2 
  \end{array}\right.
}
We merken op dat we de e-machten in het tweede geval kunnen vereenvoudigen volgens
\eq{
  e^{-2\pi i\cdot (k-n/2)j \cdot 2/n} 
  = - e^{-2\pi i\cdot kj\cdot 2/n} \quad,\quad e^{-2\pi i\cdot(k-n/2)/n} 
= -e^{-2\pi i\cdot k/n},
}
waardoor het gevalsonderscheid wegvalt, aangezien beide vergelijkingen nu identiek zijn.
We verkrijgen $X[k]$ als sommatie over de lijsten $e$ en $o$, we vullen de relatie voor $e,o$ met $x$ in, en nemen de factor voor de oneven indices mee in de sommatie.
\eq{
  X[k] = \sum^{n/2}_{j=1} x[2j] \cdot e^{-2\pi i\cdot k (2j)/n} + 
    \sum^{n/2}_{j=1} x[2j+1] \cdot e^{-2\pi i\cdot k (2j+1)/n} 
    = \sum^n_{j=1} x[j] \cdot e^{-2\pi i\cdot k j/n}
}
Dit bewijst dat de FFT hetzelfde resultaat levert als het DFT algoritme, het bewijs voor de gelijkheid van de iDFT en de inverse FFT is 
hetzelfde wanneer men de substitutie $-2\pi i \rightarrow 2\pi i$ uitvoert.
\end{proof}

\begin{opmerk}
We hebben hier telkens aangenomen, en zullen deze aanname ook doorzetten, 
dat de lengte van het ingangssignaal een macht van $2$ is. Dit is een belangrijke
eigenschap waar de variant van het FFT-algoritme dat hier gebruikt wordt door werkt. Deze versie van FFT wordt
de Radix-2 Decimation In Time van het Cooley-Tukey FFT algoritme genoemd. Algemenere vormen van het algoritme
worden ook toegepast in geoptimaliseerde algoritmes maar om de implementatie te versimpelen 
is voor Radix-2 gekozen. Eventuele verschillen in afmetingen tussen een signaal en 
een 2-macht zijn opgelost met signaalextensie, zoals eerder beschreven.
\end{opmerk}

%-----------------------------------------------------------------------------------------------------------------
\subsection{Complexiteit van de Fast Fourier Transform}
We zullen de claim bewijzen dat de complexiteit van de FFT werkelijk beter lager is dan die van de DFT.
Hiervoor hebben we de volgende stelling uit de Complexiteitstheorie nodig.\footnote{Dit is een speciaal geval van de stelling, voor de volledige stelleing en het bewijs zie \cite{akra-bazzi}.}

\begin{stelling}[Akra-Bazzi]
    Zij $T:\N\to\R$ een recurrente betrekking van de vorm
    \[
    T(n) = \begin{cases}
      c_0 &\text{ als } n \leq d \\
      a T(n/b) + f(n) &\text{ anders} \\
    \end{cases},
    \]
    waarbij $a,b,d\in\N$, $c_0\in\R$ en $f$ een functie $f:\N\rightarrow\R$ die voldoet aan 
    \[
    \exists k \in \N \,:\, f(n) \in \theta(n^{\log a/\log b} \log^k n),
    \]
    dan wordt de orde van $T(n)$ gegeven door:
    \[
      T(n) \in \theta(n^{\log a / \log b} \log^{k+1}n).
    \]
\end{stelling}
We beschouwen hier $T(n)$ als het aantal stappen dat een machine nodig heeft om het algoritme uit te voeren.
Deze stelling is voldoende om een uitspraak te kunnen doen over de complexiteit 
\begin{stelling}[Complexiteit van de FFT]
  Het Fast Fourier Transform algoritme heeft een tijds-complexiteit $\O(n\log n)$ voor input van lengte $n=2^m$ 
\end{stelling} 
\begin{proof}[Bewijs]
We schrijven het FFT algoritme in pseudocode.

\begin{algorithmic}
\Function{FFT}{$x$}
\State $n \gets \text{lengte}(x)$ \Comment Assumptie: $n = 2^m$ voor een $m$
\If {$n == 1$}
	\State{$X \gets x$}
\Else
	\State $E \gets FFT(x[0::2])$ \Comment{FFT op even indices}
	\State $O \gets FFT(x[1::2])$ \Comment{FFT oneven indices}
	\For{$i = 0$ to $n-1$}
		\If{$i < n/2$}
			\State $X[i] \gets E[i] + e^{-2i \pi k/n} \cdot O[i]$
		\Else
			\State $X[i] \gets E[i] - e^{-2i \pi k/n} \cdot O[i]$
		\EndIf
	\EndFor
\EndIf
\State \Return{$X$}
\EndFunction
\end{algorithmic}

Dit algoritme is recursief, dus kunnen we de complexiteit schrijven door middel van een recurrente betrekking. Laat hiervoor $T(n)$ het aantal berekeningen zijn dat het algoritme kost bij een invoersignaal van lengte $n$. We maken een gevalsonderscheid: als de lijst lengte $1$ heeft geven we deze direct terug (1 berekening). Bij een lijst van lengte $>1$ splitsen we de lijst op in de even en oneven entries en voeren we op beiden weer het FFT algoritme uit, vervolgens voeren we nog $n$ maal een vast aantal ($N$) berekeningen uit om tot het eindresultaat te komen. In formulevorm geeft dit de \emph{recurrente betrekking}
\[
T(n) = \begin{cases}
    1 &\text{ als } n = 1 \\
    2\cdot T(n/2) + N\cdot n &\text{ anders}. \\
\end{cases}
\]
We zullen nu bovenstaande (vereenvoudigde) stelling van Akra-Bazzi gebruiken. We rekenen hierbij niet de $\O$ van de FFT uit maar de strictere $\theta$ die gedefinieerd is volgens:
\[
f \in \theta(g) \Leftrightarrow \exists c \in \R_+: \lim_{n \to \infty} \frac{f(n)}{g(n)} = c
\]
Zonder verder al te veel in te gaan op de implicaties die $\theta$ heeft op het gedrag van de FFT vermelden we dat in ieder geval geldt dat $f \in \theta(g)$ impliceert dat $f \in \O(g)$. 

De recurrente betrekking voor de complexiteit van de FFT is inderdaad van dezelfde vorm als die van $T(n)$ in bovenstaande stelling.
Laat hiervoor namelijk $a=b=2$, $c_0=d=1$ en $f (n) = N\cdot n$:
\eq{
  f(n) \in \theta(n^{\log 2/\log 2} \log^0 n)=\theta(n).
}
Dit betekent dat $T(n) \in \theta(n \log n)$ en dus zeker $T(n) \in \O(n \log n)$.
Hiermee hebben we bewezen dat de FFT en daarmee de iFFT binnen tijdscomplexiteit $\O(n\log n)$ lopen. 
\end{proof}

\begin{opmerking}
Omdat het algoritme niet in lineaire tijd loopt, neemt de wachttijd snel toe bij grote signalen. 
In meer dimensies wordt dit al snel een praktisch bezwaar, dit is dan ook een reden waarom we geen driedimensionale 
signalen hebben bekeken bij de implementatie van de Fouriertransformatie.
\end{opmerking}

%-----------------------------------------------------------------------------------------------------------------
\section{Discrete Fourier Transform in meer dimensies}
Een eigenschap van het DFT-algoritme is dat het op een natuurlijke manier uit te breiden is naar hogere dimensies.
Per extensie daarvan is er een manier om het FFT-algoritme mee te laten schalen, die we ook zullen behandelen.
Het idee hierbij is om het Tensorproduct te nemen van meerdere bases.

\begin{definitie}[Multidimensionale Discrete Fourierbasis] 
Gegeven zij een signaalruimte van de vorm
$\R^{n_1} \times \R^{n_2} \times \ldots \times \R^{n_m}$ 
waarvan de elementen $m$-dimensionale discrete signalen zijn waarbij de $i$-de richting een lengte $n_i$ heeft.
We defini\"eren de multidimensionale discrete Fourierbasis behorende bij deze signaalruimte als
\[
  S_{\bold n}= S_{n_1}\otimes S_{n_2} \otimes \ldots \otimes S_{n_m} = 
  \left\{s_{\bold k}[{\bold j}]  = s_{k_1}[j_1]\cdot s_{k_2}[j_2]\cdot\ldots\cdot s_{k_m}[j_m] 
  \largediv s_{k_i} \in S_{n_i}, j_i \in \{1,\ldots, n_i\} \right\}
\]
Met basisvectoren $s_{\bold k}$, waar $\bold k$ een indexvector uit $\{1, \ldots, n_1\}\times\ldots\times\{1\ldots, n_m\}$ is.
Het feit dat dit een basis is, kan gevonden worden in \cite{topo}.
\end{definitie}

Wanneer we nu een $m$-dimensionaal signaal bekijken van lengte $n_1 \times \cdots \times n_m$ etc., dan kunnen we
hierop een multidimensionale Fouriertransformatie op defini\"eren door het inproduct te generaliseren naar 
onze $m$-dimensionale signaalruimte.
\begin{equation}
  \label{algemeen_fourier_schema}
  X[\bold k] = \tfrac{1}{\bold n}
  \sum_{\bold j = \bold 1}^{\bold n} x[\boldsymbol j] s^{-1}_{\bold k}[\boldsymbol j] 
  =
  \left(\prod_{i=1}^m \tfrac{1}{n_i}\right) \cdot 
  \sum_{j_1=1}^{n_1} \ldots \sum_{j_m=1}^{n_m} 
  x[j_1,\ldots,j_m] \cdot 
  e^{-\dpii\cdot k_m \cdot j_m /n_m } \cdot \ldots \cdot e^{-\dpii\cdot k_1 \cdot j_1 /n_1 } 
\end{equation}

Maar zoals we voor de DFT al gezien hadden is het uitrekenen van al deze inproducten erg complex (in de tijd).
We zullen daarom de Multidimentionale Discrete FourierTransformatie (MDFT) op een andere manier defini\"eren 
zodat we beter gebruik kunnen maken van de DFT en FFT algoritmen die we al gevonden hebben.

\begin{algo}[Multidimensionaal DFT-algoritme]
Gegeven is een $m$-dimensionale input $x$ en een huidig level $t$, 
we schrijven het algoritme met output $X_t$ volgens
\begin{equation}
  \label{mdft_cases}
  X_{t}[\boldsymbol k] = \begin{cases}
  \DFT(X_{t-1}\largediv_{x_1 = k_1,\ldots,x_{t-1} = k_{t-1},x_{t+1} = k_{t+1},\ldots,x_m =k_m})[k_t] & \text{als } t>0\\
  x[k_t] & \text{als } t=0
  \end{cases}
\end{equation}
Waar we de notatie $X\largediv_{x_i=c}$ gebruiken voor het object van kleinere dimensie dat verkregen
wordt door de $i$-de co\"ordinaat vast te leggen op $c$.
We beweren dat vervolgens $X_m$ de multidimensionale Fouriertransformatie van een $m$-dimensionaal signaal geeft zoals
in \ref{algemeen_fourier_schema}.
\end{algo}
\begin{proof}[Bewijs]
We voeren inductie naar de dimensie $m$ uit met de inductiehypothese dat voor een dimensie $m$ 
de vergelijking voor $X_m$ uit het algoritme gegeven wordt door \ref{algemeen_fourier_schema}.\\ 
Als $m=1$ dan geldt:
\[
X_1[k_1] = DFT(X_0)[k_1] = DFT(x)[k_1]
\]
Wat dus inderdaad de DFT in 1 dimensie geeft.
We gaan nu door met de inductiestap, voor algemene $m>1$ geldt:
Schrijf even kort
\[
\tilde X_{t-1}[k_t] = 
X_{t-1}\largediv_{x_1 = k_1,\ldots,x_{t-1} = k_{t-1},x_{t+1} = k_{t+1},\ldots,x_m =k_m}[k_t]
\]
\[
  X_m [\boldsymbol k] = 
  \DFT(\tilde X_{m-1})[k_m]
  = \frac 1 {n_m}\sum_{j_m=1}^{n_m} \tilde X_{m-1}[j_m] s^{-1}_{k_m}[j_m]
\]
We vatten nu $\tilde X$ op als een vector van lengte $n_m$ van $m-1$ dimensionale Fouriergetransformeerden
dit mag omdat
\[
X_{m-1}\largediv_{x_1=k_1,\ldots,x_{m-1}=k_{m-1}}[k_m] = X_{m-1}\largediv_{x_m=k_m}[k_1,\ldots,k_{m-1}]
\]
en daarmee $X_{m-1}\largediv_{x_m=k_m}$ een $m-1$-dimensionaal object is dat weer wordt gegeven door de relatie
in \ref{mdft_cases}.
Omdat we de aanname voor $m-1$ dimensies al bewezen hebben geldt nu:
\[
X_m[\boldsymbol k]  = \frac 1 {n_m}\sum_{j_m=1}^{n_m} 
\left( \frac 1 {n_{m-1}} \sum_{j_{m-1}=1}^{n_{m-1}} \left ( \cdots 
\frac 1 {n_1} \sum_{j_1=1}^{n_1} 
x[j_1,\ldots,j_m] 
\cdot s^{-1}_{k_1}[j_1]
\cdots \right ) s^{-1}_{k_{m-1}}[j_{m-1}] \right) 
s^{-1}_{k_m}[j_m]
\]
Wat precies is wat we wilden aantonen.
\end{proof}

Een belangrijk gevolg van de definitie van dit algoritme is dat de DFT term in \ref{mdft_cases}
gemakkelijk vervangen kan worden door een FFT term, beiden geven immers dezelfde output. 
Daarmee hebben we ook direct een MFFT gevonden.
De complexiteit van deze algoritmen is dan $\O( \sum_{i=1}^m \log(n_i) \prod_{j=1}^m n_j)$  voor de MFFT
t.o.v. $\O( \sum_{i=1}^m n_i \prod_{j=1}^m n_j)$ voor de MDFT.

%-----------------------------------------------------------------------------------------------------------------
\section{Compressie van een signaal onder FFT}
Tot zover is de Discrete Fourieranalyse besproken aan de hand van perfecte reconstructie, 
aan de hand van een  complete set co\"efficienten. Het doel van dit project is echter om
signalen te comprimeren; te reconstrueren aan de hand van een gelimiteerde dataset.
Om deze analyse te vegemakkelijken, zullen in deze sectie een aantal bewijzen aan bod komen die
de geinduceerde fout van zo een reconstructie relateren aan de grootte van de dataset.

We zullen het convergentie-gedrag gaan bepalen van de Fourier-transformatie voor functies die $C^k$ zijn.
We weten immers dat voor differentieerbare functies de Fourieranalyse perfect reconstrueerbaar is.
Met het convergentie gedrag van deze functies kunnen we dan kwantificeren hoe goed een functie te 
benaderen is met een eindige subset van de Fourier-getransformeerde.
We trachten daarom te bewijzen dat er een algebra\"isch verband bestaat tussen de fout en de frequentie
van de wavelets en bovendien een exponentieel verband tussen de fout en de `gladheid' van de functie.

Voor dit bewijs zullen we het Lemma van Riemann-Lebesgue gebruiken: 
\begin{lemm}[Riemann-Lebesque{\cite{fourier-fout}}]
Wanneer $g \in L_1(\R)$, dan geldt 
\eq{
	G(z) = \left|\int_{-\infty}^\infty g(t) e^{- 2 \pi i z t} dt\right| \to 0 \text{ voor } z \to \infty.
}
\end{lemm}

\begin{stelling}[Daling van de co\"effici\"enten van de Fouriergetransformeerde]
\label{fourier_daling}
  Laat $f \in L_2([a,b])$. Stel er is een $n$ z\'o dat $f \in C^n$ en voor $0\leq j\leq n$ geldt dat $f^{(j)}(a) = f^{(j)}(b)$. Dan geldt dat de $k$-de entry van de Fouriergetransformeerde $\hat f[k]$ in absolute waarde
  daalt met $k$ volgens $\O(|k|^{-n})$.
\end{stelling}
\begin{proof}[Bewijs]
  Laat $f \in L_2([a,b])$ zodat $f$ voldoet aan de voorwaarden in de stelling voor een bepaalde $n$. 
  De Fourier-getransformeerde van $f$ wordt gegeven door:
  \eq{
    \hat f [k] = \tfrac{1}{\sqrt{b-a}} \inpr{f}{\phi_k}.
  }
  De constante in deze vergelijking heeft geen invloed op de orde, dus richten we ons op het inproduct. 
  We schrijven dit uit tot een integraal en voeren vervolgens, omdat $f$ differentieerbaar is, partie\"ele
  integratie uit.
  \eq{
    \abso{\inpr{f}{\phi_k}} 
    =& \abso{\int_a^b f(x) e^{- 2 \pi i k \tfrac{x-a}{b-a}} dx}
    = \abso{\tfrac{b-a}{2 \pi i k}\left[ f(x) \cdot  e^{- 2 \pi i k \tfrac{x-a}{b-a}} \right]_a^b} 
    + \abso{\frac{b-a}{2 \pi i k}\right| \left|\int_0^1 f'(x) e^{-2 \pi i k \tfrac{x-a}{b-a}} dx} \\
    =& \abso{ f(b) \cdot 1 - f(a) \cdot 1} + \frac{b-a}{2 \pi \abso{k}} 
    \abso{ \int_a^b f'(x) e^{-2 \pi i k \tfrac{x-a}{b-a}} dx }
    = \tfrac{b-a}{2 \pi |k|} \left| \int_a^b f'(x) e^{-2 \pi i k \tfrac{x-a}{b-a}} dx \right|.
  }
  Hier hebben we gebruikt dat alle afgeleiden van $0$ tot $n$ periodiek zijn.
  Omdat $f$ nu $C^n$ is en de afgeleiden weer periodiek zijn kunnen we dit herhaald toepassen,
  we verkrijgen daarmee
  \[
  \left| \int_a^b f(x) e^{-2 \pi i k \tfrac{x-a}{b-a}} dx \right| 
  = (\tfrac{2 \pi}{b-a} |k|)^{-n}\left| \int_a^b f^{(n)}(x) e^{- 2 \pi i k \tfrac{x-a}{b-a}} dx \right|.
  \]
  
  Vermenigvuldig beide kanten met $(\tfrac{2 \pi}{b-a} |k|)^n$ om te vinden dat
  \[
  (\tfrac{2 \pi}{b-a} |k|)^n \abso{\inpr{f}{\phi_k}} 
  = \abso{\int_a^b f^{(n)}(x) e^{- 2 \pi i k \tfrac{x-a}{b-a}} dx}.
  \]
  We willen graag het lemma van Riemann-Lebesgue toepassen op de rechterkant. 
  Merk daartoe op dat omdat $f \in C^n$, $f^{(n)}$ continu op $[a,b]$ 
  dus neemt hier een maximum en een minimum aan. 
  Daarmee is de integraal van $|f|$ begrensd en dus is $f\in L_1([a,b])$. 
  Maar een functie die integreerbaar is op $[a,b]$ en daarbuiten nul, is integreerbaar op $\R$. 
  Dus we mogen Riemann-Lebesgue gebruiken om te zien dat
  \[
  (\tfrac{2 \pi}{b-a} |k|)^n \abso{\inpr{f}{\phi_k}} \to 0 \text{ als } |k| \to \infty.
  \]
  Maar dit betekent precies dat $\abso{\inpr{f}{\phi_k}} \in  o((\tfrac{2 \pi}{b-a} |k|)^{-n}) = o(|k|^{-n})$
\end{proof}

De analyse van de co\"effici\"enten die we hier gegeven hebben vertaalt direct naar de fout die we krijgen
bij reconstructie van een Fourier-getransformeerde functie wanneer we een gelimiteerde dataset gebruiken.

\begin{gevolg}
Schrijf namelijk $f|_{N}$ voor de reconstructie met de eerste $N$ basisfuncties. Dan hebben we de relatie
\[
  || f - f|_N||^2_{L_2([a,b])} = \sum_{k=1}^\infty |\inpr{f-f|_N}{\phi_k}|^2 = \sum_{k=1}^\infty |\inpr{f}{\phi_k} 
  - \inpr{f|_N}{\phi_k}|^2 = \sum_{k=N+1}^\infty |\inpr{f}{\phi_k}|^2,
\]
vanwege de Parsevalgelijkheid \ref{parseval}. Omdat stelling \label{fourier_daling} geldt, zijn er $k_0, c$ zodat $\abso{\inpr{f}{\phi_k}} < c\cdot k^{-n}$ voor $k > k_0$. Dus
\[
	\sum_{k=N+1}^\infty | \langle f, \phi_{k} \rangle |^2 \leq \sum_{k=N+1}^\infty c \cdot k^{-2n} < c \cdot \int_{N}^\infty x^{-2n} dx = c \cdot \left[ \frac{x^{1-2n}}{1-2n} \right]^\infty_N = c \cdot \frac{N^{1-2n}}{2n-1}.
\]
Dan
\[
N^{2(n-1)} \cdot \sum_{N+1}^\infty |\inpr{f}{\phi_k}|^2 < N^{2(n-1)} \cdot c \cdot \frac{N^{1-2n}}{2n-1} = \frac{c}{2n-1} N^{-1} \to 0 \quad \text{als } N\to\infty,
\]
wat precies betekent dat
\[
||f-F||^2_{L_2([a,b])} \in o\left ( N^{-2(n-1)} \right) \implies ||f - F||_{L_2([a,b])} \in o\left(N^{-(n-1)}\right).
\]
\end{gevolg}

\subsection{De fout in discrete geval}
Wanneer we een discrete functie bekijken zullen we het criterium van \emph{gladheid} niet kunnen gebruiken,
we bekijken de functie immers op een deelverzameling van $\Z$ en daar is geen enkele 
niet-constante functie continu op.
We beroepen ons daarom op de analogie tussen het discrete en non-discrete geval.
De gladheid van een discrete functie $f:A\to\R$ wordt bepaald door de verschillen $f[x]-f[x+1]$,
wanneer de verschillen klein zijn en de verzameling $A$ groot is komt dit overeen met de afgeleide van een 
continue functie en zeggen we dat de functie glad is. Zo kunnen we analoga geven voor hogere afgeleiden.
Het is mogelijk om een rigoreuze beschrijving van gladheid te geven door parti\"eele sommaties te gebruiken,
maar daar zullen we niet op in gaan.

