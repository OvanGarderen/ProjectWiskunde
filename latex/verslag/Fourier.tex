\documentclass[11pt]{amsart}

\usepackage{amssymb, amsmath}
\usepackage{a4wide}
\usepackage{algpseudocode}
\usepackage{algorithmicx}

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\A}{\mathbb{A}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\e}{\epsilon}
\renewcommand{\O}{\mathcal{O}}

\newcommand{\FFT}{\text{FFT}}

\newtheorem*{lemm}{Lemma}
\newtheorem*{stelling}{Stelling}
\newtheorem*{algo}{Algoritme}
\newtheorem*{definitie}{Definitie}

\theoremstyle{remark}
\newtheorem*{opmerk}{Opmerking}

\newcommand{\eq}[1]{\begin{eqnarray*} #1 \end{eqnarray*}}
\newcommand{\mogelijkheden}[1]{\begin{cases} #1 \end{cases}}
\newcommand{\repr}[1]{{#1}^{\!\!-1}}

\newcommand{\coefficient}{co\"effici\"ent}
\newcommand{\coefficienten}{co\"effici\"enten}

\newcommand{\dx}{\text{d}x}
\newcommand{\dy}{\text{d}y}
\newcommand{\dz}{\text{d}z}
\newcommand{\largediv}{\,\big|\,}
\newcommand{\Ldnorm}[1]{{||#1||_{L_2}}}
\newcommand{\inpr}[2]{\langle #1 , #2 \rangle}
\setlength\parindent{0pt}

\newcommand{\dpii}{{2\pi i}}

\parskip = \baselineskip

\begin{document}
\section{Een inleiding in Fourier}
Studie van signalenperiodieke functies / 
een manier om een functie te ontbinden in terugkerende patronen /
karakteristiek van functie in termen van bepaalde frequenties /
overtuigendere manier om `nette' functies te beschrijven /
multiresolutie in de tijd

TODO: Periodieke functies zijn ook wel te beschrijven door slechts naar \'e\'en fase te kijken.

\subsection*{De Fourier Basis}
De basisfuncties waarmee we een functie karakteriseren bij Fourier-analyse worden gegeven door de complexe
$e$-machten.
\begin{definitie}[Fourier-Basis] Zij gegeven een interval $[a,b]$, en bekijk de functie ruimte $L_2([a,b])$. Laat de verzameling $F_{[a,b]}$ gedefinieerd zijn door:
\eq{
  F_{[a,b]} := \left\{ \phi_k(x) = \tfrac{1}{\sqrt{b-a}} e^{2 \pi i \cdot k \frac{x-a}{b-a}} \largediv k \in \N_0 \right\}
}
Dan noemen we $F_{[a,b]}$ de Fourier-`basis' van $L_2([a,b])$
\end{definitie}
Merk op dat hier het woord $basis$ nog tussen aanhalingstekens staat, we zullen eerst moeten bewijzen dat deze
verzameling ook echte een (complexe) orthonormale basis vormt voor de $L_2$ ruimte.

Ten eerste zullen we zien dat alle elementen van $F_{[a,b]}$ orthonormaal zijn t.o.v. het complexe inproduct van functies en zijn geinduceerde norm.

\eq{
  \inpr{\phi_k}{\phi_j} = \frac{1}{(b-a)}\int_{[a,b]} e^{\frac{2\pi i}{b-a} x k} 
                                                             e^{-\frac{2\pi i }{b-a} x j} \dx
                        = \frac{1}{2\pi}\int_{[0,2\pi]} e^{iy(k-j)} \dy =
                          \begin{cases}
                            \,0&\quad \text{als } k\neq j \\
                            \,1&\quad \text{als } k=j
                          \end{cases}
}
Hieruit volgt dat de elementen van $F_{[a,b]}$ een orthonormale basis vormen voor de ruimte $\tilde F = \text{span}(F_{[a,b]})$.
We willen nu bewijzen dat de re\"ele projectie van deze ruimte dicht ligt in de re\"ele functieruimte $L_2([a,b])$
We zullen hier eerst een aantal handige definities voor introduceren.

\begin{definitie}[Fourier-getransformeerde]
Zij gegeven een functie $f\in L_2({[a,b]})$, schrijf dan een vector $\hat f \in \C^\infty$ met entries gedefinieerd volgens (hier aangegeven met blokhaken):
\eq{
  \hat f [n] = \frac{1}{\sqrt{b-a}} \cdot \inpr{f}{\phi_n} = \frac{1}{b-a} \int_{[a,b]} f(x) \cdot e^{-2 \pi i \cdot k \frac{x-a}{b-a}}\dx 
}
We noemen $\hat f$ de Fourier-getransformeerde van $f$.
\end{definitie}

TODO: Bewijzen dat alle re\"ele functies in de ruimte opgespannen door de Fourier-basis dicht liggen in $L_2$.

TODO: Bewijzen dat de continue reconstructie perfect is wanneer $f \in C^1$

%\eq{
%  \int_{[a,b]} f(x) e^{q(x)} dx \leq \Ldnorm{f}\Ldnorm{e^{q(x)}} 
%}

%-----------------------------------------------------------------------------------------------------------------
\section{De `Discrete Fourier Transform'}
Zoals we gezien hebben in het vorige hoofdstuk kan de Fourier-transformatie gebruikt worden om continue signalen te karakteriseren voor verschillende frequenties. Een groot gebied binnen de signaal-analyse is echter van discrete aard aangezien hier toch veelal digitale instrumenten voor worden gebruikt. De toepassingen waar wij op zoek zijn liggen ook in dit digitale domein (JPEG is immers een beeld-compressie algoritme) en dus zal ons verslag zich verder afspelen in deze discrete setting.

Om voor discrete signalen te analyseren lijkt het in eerste instantie voor de hand te liggen om het discrete signaal als stapfunctie te bekijken, deze is immers ook kwadratisch integreerbaar. Dit lijdt echter tot ongewenste resultaten, zoals is te zien aan de reconstructie van een blokgolf door middel van Fourier-transformatie. Erger nog, elke eindige som van continue functies is weer continue dus voor een perfecte reconstructie van een discreet signaal is met deze methode altijd een oneindige rij \coefficient en nodig. Bovendien is het moeilijk om uit deze \coeffiecienten~relevante informatie te destileren over de aard van het signaal.

In plaats van de discrete signalen in te bedden in $L_2$ zullen we een discreet analogon gebruiken, om de Fourier-transformatie van praktisch nut te laten zijn in de analyse van discrete signalen. 
Hiervoor zullen we de Fourier-basis moeten discretiseren en ons moeten richten op de ruimte $\R^n$.
We doen dit op zo'n manier dat deze discretisatie in de limiet naar het continue geval overgaat. 
Zo zullen we uiteindelijk tot de \emph{Discrete Fourier Transform} decompositie komen.

\begin{definitie}[Discrete Fourier-Basis] Gegeven de ruimte $\R^n$ definieer dan de verzameling
\eq{
  S_n := \left\{ s_k [j] = e^{\dpii k j/n } \largediv k,j \in \{0..n\} \right\}
}
Als zijnde de discrete Fourier-basis met basisvectoren $s_k$.
\end{definitie}
\vspace{-10pt}
Met deze basis in de hand kunnen we vervolgens de discrete Fourier getransformeerde (DFT) van een signaal schrijven als de vector van (complexe) inproducten van dit signaal met de DFT-basisfuncties. Laat voor een signaal $x$ van lengte $n$ de DFT (aangeduid met $X$) gegeven zijn door:
\eq{
  X[k] = \tfrac{1}{n} \inpr{x}{s_k} \quad k\in\{0..n\}
}
Ook defini\"eren we de een operatie op zulke vectoren $X$ en beweren dat deze een inverse DFT (iDFT) voorstelt, dit bewijs volgt weldra in een volgende sectie. De iDFT wordt gegeven door
\eq{
  x[j] = \inpr{X}{s_j^{-1}} \quad j\in \{0..n\}
}
We zullen nu enkele bewijzen geven om de term `Discrete Fourier Basis' te ondersteunen.

\subsection*{Orthonormaliteit van de basisvectoren}
We zullen bewijzen dat de verzameling $S_n$ een orthogonale basis is voor $\R^n$. Bekijk hiervoor een inproduct tussen twee
willekeurig gekozen elementen van deze verzameling:
\eq{
  \inpr{s_k}{s_j} = \sum_{m\leq n} s_k[m]\cdot \overline{s_j[m]} = \sum_{m\leq n} e^{\dpii\cdot m (k-j)/n} =
  \begin{cases}
    0 \quad \text{als } k\neq j\\
    n \quad \text{als } k = j
  \end{cases}
}

\subsection*{Limiet naar continue geval}
Om de claim te ondersteunen dat de DFT methode een echte discretisatie is van de continue Fourier-transformatie willen we bewijzen dat dit algoritme voor een steeds fijnere selectie van waardes van een functie in de limiet hetzelfde resultaat geeft als de continue Fourier transformatie. 
Zoals gebruikelijk bij het overschakelen van een discrete naar een continue setting, kunnen we dit doen 
door de definitie van de Riemann integraal toe te passen op de sommatie die voor handen ligt.

\begin{proof}[Bewijs]
Gegeven een interval $[a,b]$ en een functie $f \in L_2([a.b)$ kunnen we een partitie P maken in $n$ gelijke delen.
We nemen $P$ als de punten $a<\tfrac{na + b-a}{n}<\ldots<\tfrac{na + j(b-a)}{n}<\ldots<b$.
We discretiseren onze functie $f$ door uit elk interval van de partitie de volgende randwaarde te pakken:
$f[j] = f(\frac{b-a}{n}j + a)$.
De DFT van de functie $f$ wordt dan gegeven door het inproduct te nemen met de DFT-basisfuncties:
$F[k] = \frac1n\sum_{j\leq n} f[j] \cdot s_k[j]$
We schrijven dit om in termen van onze partitie, met de identificatie $n\cdot\tfrac{x-a}{b-a} = j$ waarmee we 
de continue variable $x\in[a,b]$ omschrijven naar zijn discrete tegenhanger en krijgen zo:
\eq{
  F[k] =& \frac{1}{n} \sum_{x \in P} f[n\cdot\tfrac{x-a}{b-a}]\cdot s_k[n\cdot\tfrac{x-a}{b-a}] \\
       =& \frac{1}{n} \sum_{x \in P} f(x)\cdot e^{\dpii \cdot k \tfrac{x-a}{b-a}} \\
       =&  \frac{1}{\sqrt{b-a}}\sum_{x \in P} f(x)\cdot \phi_k(x) \frac{b-a}{n}}
}
We merken op dat de factor $\frac{b-a}{n}$ precies de grootte is van ons interval en dat we het geheel
omgeschreven hebben in termen van onze continue functies $f$ en $\phi_k$.
Omdat het product $f\cdot\phi_k$ integreerbaar is moet voor elke partitie $P$ met 
waarden in punten $x$ uit elk interval deze sommatie convergeren naar de integraal
\eq{
  \frac{1}{\sqrt{b-a}} \int_{[a,b]} f(x) \phi_k(x) dx
}
wanneer we de maaswijdte ($\tfrac{b-a}{n}$) naar $0$ laten gaan. Dit is duidelijk het geval wanneer we de limiet $n\to\infty$ nemen. Daarmee is de DFT een goede discretisatie van de Fourier getransformeerde. 
\end{proof}
 
\subsection*{Inverteerbaarheid van de DFT}
Voor de werking van het DFT algoritme als signaal-compressie algoritme is het van belang dat er een 
inverse algoritme bestaat dat het getransformeerde ingangs-signaal weer terugtransformeert 
zonder verlies van informatie.

\begin{proof}[Bewijs]
We zullen bewijzen dat de DFT en iDFT elkaars inversen zijn.
We bekijken daarvoor een signaal $x\in\R^n$ dat met de DFT methode getransformeerd wordt in een vector $X\in\C^n$.
Hierbij hoort dan de discrete Fourier-basis $S_n$ met basisvectoren $s_k$. 

Hiermee zijn de discrete Fourier transformatie en zijn inverse gedefini\"eerd door:
\eq{
  X_k = \tfrac 1 n \langle x, s_k \rangle \quad\quad \text{(DFT)}\\
  x_j =  \langle X, \repr{s_j} \rangle \quad\quad\text{(iDFT)}
}
Om te bewijzen dat de iDFT de DFT inverteert voldoet het om de iDFT uit te schrijven in termen van $x$ 
door $X$ in te vullen volgens de formule van de DFT. Uitschrijven hiervan geeft:
\eq{
  \hat x_j =&  \langle X , \repr{s_j} \rangle \\
      =&  \sum_{i=1}^n X_i\cdot \overline{\repr{s_j}[i]} \\
      =&  \sum_{i=1}^n \tfrac1n\inpr{x}{s_i} \overline{\repr{s_j}[i]} \\
      =& \langle x , \frac1n \sum_{i=1}^n s_i \repr{s_j}[i] \rangle
}
Rest ons nog om aan te tonen dat deze sommatie over de transformatie-vectoren een eenheids-vector oplevert, 
namelijk dat
\eq{
  \frac1n \sum_{i=1}^n s_i \repr{s_j}[i] =& e_j
}
Hiervoor schrijven we de sommatie (die een vector van lengte $n$ representeert) uit in zijn componenten. 
Merk nu op dat de discrete Fourier-basisvectoren zo gedefinieerd zijn dat $s_k[m] = s_m[k]$. 
We verwisselen dus de indices in blokhaken met die in het subscript van $s$ en verkrijgen daarmee
\eq{
  \frac1n \sum_{i=1}^n s_i[m] \repr{s_j}[i] = \frac1n \sum_{i=1}^n s_m[i] \overline{s_j[i]} 
=\tfrac1n \inpr{s_m}{s_j} = \begin{cases}0\quad\text{als }m\neq j\\1\quad\text{als }m=j\end{cases}.\\
}
Hier gebruiken we dus de eerdere vergelijking voor het inproduct van twee basisfuncties.
We gebruiken deze eigenschap van de sommatie om ons eerder inproduct uit te schrijven. 
We hebben nu een gelijkheid
\eq{
  \hat x_j = \inpr{x,e_j} = x_j
}
Door de iDFT toe te passen op het resultaat van de DFT zullen we dus altijd het origineel terug krijgen,
dus de iDFT inverteert de DFT
\end{proof}

%-----------------------------------------------------------------------------------------------------------------
\section{De Fast Fourier Transform}
De snelheid van het DFT algoritme valt in de praktijk nogal tegen, het nemen van $n$ inproducten over vectoren 
van lengte $n$ heeft namelijk een tijdscomplexiteit van $\O(n^2)$. Dit staat de directe implementatie van de DFT 
voor praktische toepassingen in de weg. Daarom is er een alternatief algoritme, de \emph{Fast Fourier Transform}.  \bigskip

%%%%%
\begin{algo}[Fast Fourier Transform]
Gegeven zij een input signaal $x$ van lengte $2^n$, dan geeft het algoritme $\FFT$ 
een lijst terug van waardes $X$ van lengte $2^n$ als volgt:

Als $n=0$ dan geeft de $\FFT$ de lijst (van \'e\'en element) direct terug:
\eq{
X = x
}
Wanneer $n\neq0$ splitsen we de lijst $x$ op in lijsten $\e,o$ van zijn even en oneven indices:
\eq{
  \e_k   =& x_{2k}   &\quad \text{voor } k < 2^{n-1}\\
   o_k   =& x_{2k+1} &\quad \text{voor } k < 2^{n-1}
}
Vervolgens voeren we hierop het $\FFT$ algoritme uit om de volgende lijsten te verkrijgen:
\eq{
  E =& \FFT(\e) \\
  O =& \FFT(o)
}
Hiermee wordt de output van het algoritme geconstrueerd als volgt:
\eq{
  X_k = \left\{\begin{array}{llll}
    E_k         &+& e^{-i2\pi k2^{-n}} O_k &  k< 2^{n-1} \\
    E_{(k-2^{n-1})} &-& e^{-i2\pi (k-2^{n-1})2^{-n}} O_{(k-2^{n-1})} &  k\geq N/2 
  \end{array}\right.
}
\end{algo}
%%%%%

Dit is dus een recursief gedefinieerd algoritme dat een signaal meermaals halveert en in zichzelf terugvoert.
Ook is het gegarandeerd dat dit algoritme afloopt vanwege de conditie op $n=0$ samen met de halvering van de input bij elke stap. Een belangrijke voorwaarde voor de relevantie van de FFT is nu dat het algoritme hetzelfde resultaat geeft als het DFT algoritme en dit zullen we nu dan ook bewijzen. 

\begin{proof}[Bewijs]
We gebruiken hier een inductie bewijs met inductie naar $n$, onze aanname is dat het FFT algoritme voor $x$ van lengte $n=2^m$ gelijk is aan de DFT van $x$, ofwel
\eq{
  X_k = \sum^{N}_{k=1} x_j \cdot e^{-2\pi i \cdot jk/n}
}
Dit geldt duidelijkerwijs wanneer $m=0$, onze basistap, hier hebben we namelijk:
\eq{
  X_k = x_k = x_1 = \sum^{2^0}_{k=1} x_j \cdot e^{-2\pi i \cdot 1/2^0}
}
Vervolgens passen we inductie toe naar $m$ door onze aanname voor $m-1$ te gebruiken,
we vullen hiermee $E_k$ en $O_k$ in de vergelijking voor $X_k$ in, deze hebben immers lengte $n=2^{m-1}$.
\eq{
  X_k = \left\{\begin{array}{llll}
    \sum^{n/2}_{j=1} \e_j \cdot e^{-2\pi i \cdot kj \cdot 2/n} &+& 
    e^{-2\pi i \cdot k/n}
    \sum^{n/2}_{j=1} o_j \cdot e^{-2\pi i\cdot kj \cdot 2/n} &  k< n/2 \\
    \sum^{n/2}_{j=1} \e_j \cdot e^{-2\pi i\cdot (k-n/2) j\cdot 2/n} &-& 
    e^{-2\pi i\cdot (k-n/2)/n}
    \sum^{n/2}_{j=1} o_j \cdot e^{-2\pi i\cdot (k-n/2)j\cdot 2/n} &  k\geq n/2 
  \end{array}\right.
}
We merken op dat we de e-machten in het tweede geval kunnen vereenvoudigen volgens
\eq{
  e^{-2\pi i\cdot (k-n/2)j \cdot 2/n} 
  = - e^{-2\pi i\cdot kj\cdot 2/n} \quad,\quad e^{-2\pi i\cdot(k-n/2)/n} 
= -e^{-2\pi i\cdot k/n},
}
waardoor het gevalsonderscheid wegvalt, aangezien beide vergelijkingen nu identiek zijn.
We verkrijgen $X_k$ als sommatie over de lijsten $e$ en $o$, we vullen de relatie voor $e,o$ met $x$ in, en nemen de factor voor de oneven indices mee in de sommatie.
\eq{
  X_k = \sum^{n/2}_{j=1} x_{2j} \cdot e^{-2\pi i\cdot k (2j)/n} + 
    \sum^{n/2}_{j=1} x_{2j+1} \cdot e^{-2\pi i\cdot k (2j+1)/n} 
    = \sum^n_{j=1} x_j \cdot e^{-2\pi i\cdot k j/n}
}
Dit bewijst dat de FFT hetzelfde resultaat levert als het DFT algoritme, het bewijs voor de gelijkheid van de iDFT en de inverse FFT is 
hetzelfde wanneer men de substitutie $-2\pi i \rightarrow 2\pi i$ uitvoert.
\end{proof}

\begin{opmerk}
We hebben hier aangenomen, en zullen deze aanname ook doorzetten, dat de lengte van het ingangssignaal een macht van $2$ is, dit is een belangrijke
eigenschap waar de variant van het FFT algoritme dat hier gebruikt wordt door werkt. Deze smaak van FFT wordt
de Radix-2 Decimation In Time van het Cooley-Tukey FFT algoritme genoemd. Algemenere vormen van het algoritme
zijn ook mogelijk maar om niet al te veel te dralen bij de implementatie is dit simpel gehouden.
(Eventuele verschillen in afmetingen worden dan opgelost met signaalextensie.
\end{opmerk}

%-----------------------------------------------------------------------------------------------------------------
\subsection*{Complexiteit van de Fast Fourier Transform}
Hoewel het vanuit een puur wiskundig oogpunt wellicht minder relevant is, is de complexiteit van een algoritme 
als een factor van belangrijk praktisch nut. De complexiteit vertaalt namelijk direct naar 
de looptijd van het algoritme. We zullen daarom bewijzen dat de complexiteit van de FFT 
een element is van $\O(n \log n)$. Ook is daarmee de complexiteit van de iFFT vastgesteld aangezien deze hetzelfde schema volgt met andere co\"efficienten. 

\begin{proof}[Bewijs]
We schrijven het FFT algoritme in pseudocode.

\begin{algorithmic}
\Function{FFT}{$x$}
\State $n \gets \text{lengte}(x)$ \Comment Assumptie: $n = 2^m$ voor een $m$, oftewel $n$ is een tweemacht
\If {$n == 1$}
	\State{$X \gets x$}
\Else
	\State $E \gets FFT(x[0::2])$ \Comment{Pak alle even indices}
	\State $O \gets FFT(x[1::2])$ \Comment{Pak alle oneven indices}
	\For{$i = 0$ to $n-1$}
		\If{$i < n/2$}
			\State $X[i] \gets E[i] + e^{-2i \pi k/n} \cdot O[i]$
		\Else
			\State $X[i] \gets E[i] - e^{-2i \pi k/n} \cdot O[i]$
		\EndIf
	\EndFor
\EndIf
\State \Return{$X$}
\EndFunction
\end{algorithmic}

Dit algoritme is recursief, dus kunnen we de complexiteit schrijven door middel van een recurente betrekking. Laat hiervoor $T(n)$ het aantal berekeningen zijn dat het algoritme kost bij een invoersignaal van lengte $n$. We een gevals onderscheid: als de lijst lengte $1$ heeft geven we deze direct terug (1 berekening), en anders gaan we de recursie in. Bij een lijst van lengte $>1$ splitsen we de lijst op in de even en oneven entries en voeren we op beiden weer het FFT algoritme uit, vervolgens voeren we nog $n$ maal een vast aantal berekeningen (= c berekeningen) uit om tot het eindresultaat te komen. In formulevorm geeft dit de volgende \emph{recurrente betrekking}
\[
T(n) = \begin{cases}
    1 &\text{ als } n = 1 \\
      2\cdot T(n/2) + c\cdot n &\text{ anders} \\
\end{cases}
\]
We zullen nu een stelling uit complexiteits theorie gebruiken die betrekking heeft op algoritmes van deze vorm, namelijk de (vereenvoudigde) stelling van Akkra-Bazzi. We rekenen hierbij niet de $\O$ van de FFT uit maar de strictere $\theta$ die gedefinieerd is volgens:
\[
f \in \theta(g) \Leftrightarrow \exists c \in \R_+: \lim_{n \to \infty} \frac{f(n)}{g(n)} = c
\]
Zonder verder al te veel in te gaan op de implicaties die $\theta$ heeft op het gedrag van de FFT gebruiken we dan dat in ieder geval geldt dat $f \in \theta(g)$ impliceert dat $f \in \O(g)$. 
De stelling die voor dit probleem van belang is, is de vereenvoudigde stelling van \emph{Akkra-Bazzi}.

%%%%%
\begin{stelling}[Akkra-Bazzi]
Zij $T(n)$ recurrente betrekking van de vorm
\[
T(n) = \begin{cases}
  c &\text{ als } n \leq d \\
  a T(n/b) + f(n) &\text{ anders} \\
\end{cases},
\]
waarbij $a,b,d\in\N$, $c\in\R$ en $f$ een functie $f:\N\rightarrow\R$ die voldoet aan 
\eq{
  \exists k \in \N \,:\, f(n) \in \theta(n^{\log a/\log b} \log^k n).
}
Dan wordt de orde van $T(n)$ gegeven door:
\eq{
  T(n) \in \theta(n^{\log a / \log b} \log^{k+1}n).
}
\end{stelling}
%%%%%

De recurrente betrekking voor de complexiteit van de FFT is inderdaad van dezelfde vorm als die van $T(n)$ in bovenstaande stelling.
Laat hiervoor namelijk $a=b=2$, $c=d=1$ en $f$ de functie die $n\mapsto n$ dan voldoet $f$ aan:
\eq{
  f(n) \in \theta(n^{\log 2/\log 2} \log^0 n)=\theta(n).
}
Dit betekent dat $T(n) \in \theta(n \log n)$ en dus zeker $T(n) \in \O(n \log n)$.
Hiermee hebben we bewezen dat de FFT en daarmee de iFFT binnen tijdscomplexiteit $\O(n\log n)$ lopen. 
\end{proof}

%-----------------------------------------------------------------------------------------------------------------
\section{Discrete Fourier Transform in meer dimensies}
Een eigenschap van het DFT algoritme is dat het op een natuurlijke manier uit te breiden is naar hogere dimensies.
Per extensie daarvan is er een manier om het FFT algoritme mee te laten schalen, die we ook zullen behandelen.
Het idee hierbij is om het tensorproduct te nemen van meerdere bases.

\begin{definitie}[Multidimensionale Discrete Fourier-Basis] 
Gegeven zij een signaalruimte van de vorm
$\R^{n_1} \times \R^{n_2} \times \ldots \times \R^{n_m}$, we vatten dit op als
een $m$-dimensionaal discreet signaal waarbij de $i$-de orthogonale richting een lengte $n_i$ heeft.
Dan definieeren we de multidimensionale discrete Fourier-basis behorende bij deze signaalruimte als
\eq{
  S^m = S_{n_1}\otimes S_{n_2} \otimes \ldots \otimes S_{n_m} = 
  \left\{s^ = (s_{k_1},s_{k_2},\ldots,s_{k_m}) \largediv s_{k_i} \in S_{n_i} \right\}
}

\end{definitie}

Wanneer we nu een $m$-dimensionaal signaal bekijken van lengte $n_1$ bij $n_2$ etc., dan kunnen we
hierop een multidimensionale Fourier transformatie op definieren door:
\eq{
  (X_1,X_2,\ldots,X_m) = 
  (\sum_{j_1} \ldots \sum_{j_m} \inpr{s_{}}{}
  )
}
TODO: WTF man dit is echt een stuk moeilijker dan ik in mn hoofd had, ik zal nog eens kijken naar tensoren enzo
in principe zou je daar wel iets over moeten kunnen zeggen denk ik.
Iets over mappings over rijen en kolommen en andere vormen maar ik weet niet hoe het schaalt naar dimensie $m$

%-----------------------------------------------------------------------------------------------------------------
\section{Compressie van Beeldmateriaal onder FFT}
TODO: een klein lulverhaaltje hier en daar, even uitleggen wat er nodig is enzo hoeft niet heel lang te zijn

\subsection*{Verwachte ontwikkeling van de fout}
Het is zowel van praktisch nut als wiskundig interessant om het convergentie-gedrag te bepalen 
van de Fourier-transformatie. Met het convergentie gedrag voor continue functies kunnen we immers
kwantificeren hoe goed een functie te benaderen is met een eindige subset van de Fourier-getransformeerde.
We trachten daarom te bewijzen dat er een algebra\"isch verband bestaat tussen de fout en de frequentie
van de wavelets en bovendien een exponentieel verband tussen de fout en de `gladheid' van de functie.

\begin{proof}[Bewijs]
Laat $f \in L_2[0,1]$. Stel $f$ is $C^n$ en periodiek (voor alle afgeleides $f^{(j)}$ geldt $f^{(j)}(1) = f^{(j)}(0)$). Dan kunnen we iets zeggen over de mate van daling in de co\"effici\"enten.

Voor dit bewijs zullen we het Lemma van Riemann-Lebesgue gebruiken: TODO-bewijs of referentie.
\begin{lemm}[Riemann-Lebesque]
Wanneer $g \in L^1(\R)$, dan geldt
\[
	G(z) = \left|\int_{-\infty}^\infty g(t) e^{- 2 \pi i z t} dt\right| \to 0 \text{ voor } z \to \infty.
\]
\end{lemma}

Wij willen graag iets zeggen over $\langle f, \psi_k\rangle$, de $k$-de co\"effici\"ent van onze Fourierbasis. Dan:
\[
	|\langle f, \psi_k \rangle| = \left|\int_0^1 f(x) e^{- 2 \pi i k x} dx\right| = \left|\left[ f(x) \cdot \frac{-1}{2 \pi i k} e^{- 2 \pi i k x} \right]_0^1\right| + \left|\frac{1}{2 \pi i k}\right| \left|\int_0^1 f'(x) e^{-2 \pi i k x} dx \right|
\]
\[
	= | f(1) \cdot 1 - f(0) \cdot 1| + \frac{1}{2 \pi k} \left| \int_0^1 f'(x) e^{-2 \pi i k x} dx \right| = \frac{1}{2 \pi |k|} \left| \int_0^1 f'(x) e^{-2 \pi i k x} dx \right|.
\]
Omdat $f$ nu $C^n$ is, kunnen we dit herhaald toepassen, we verkrijgen daarmee
\[
	\frac{1}{2 \pi k} \left| \int_0^1 f(x) e^{-2 \pi i k x} dx \right| = (2 \pi |k|)^{-n}\left| \int_0^1 f^{(n)}(x) e^{- 2 \pi i k x} dx \right|.
\]
Vermenigvuldig beide kanten met $(2 \pi |k|)^n$ om te vinden dat
\[
	(2 \pi |k|)^n |\langle f, \psi_k \rangle| = \left| \int_0^1 f^{(n)}(x) e^{- 2 \pi i k x} dx \right|.
\]
We willen graag het lemma van Riemann-Lebesgue toepassen op de rechterkant. Merk daartoe op dat omdat $f \in C^n$, $f^{(n)}$ continu op $[0,1]$ dus neemt hier een maximum en een minimum aan. Daarmee is de integraal van $|f|$ begrensd en dus is $f\in L_1[0,1]$. Maar een functie die integreerbaar is op $[0,1]$ en daarbuiten nul, is integreerbaar op $\R$. Dus we mogen Riemann-Lebesgue gebruiken om te zien dat
\[
	(2 \pi |k|)^n |\langle f, \psi_k \rangle| \to 0 \text{ als } |k| \to \infty \Rightarrow \langle f, \psi_k \rangle \in o((2 \pi |k|)^{-n}) \subset O((2 \pi |k|)^{-n}) = O(|k|^{-n}),
\]
oftewel een algebraische afname van de co\"efficienten .
\end{proof}
TODO: hier nog een corollary bij schrijven om de coefficienten aan de fout gelijk te praten.

\subsection*{De fout in discrete geval}

TODO: bla bla bla discreet $\to$ continu voor grote dataset, verder nog een definitie van smooth geven op discrete functies

%-----------------------------------------------------------------------------------------------------------------
\section{Implementatie van Fourier Transformatie in Python}
Leldeux

TODO: uhm, een beetje lullen over de code die we geschreven hebben
\end{document}
