\chapter{Intro}

\section{Signaaluitbreiding}
\label{signaal}
Beide algoritmes kunnen enkel omgaan met signalen die een tweemacht lang zijn. Om te zorgen dat een willekeurig signaal ook getransformeerd kan worden, moet het dus uitgebreid worden voorbij zijn definitiegebied. De meeste bronnen onderscheiden de volgende manieren om het signaal uit te breiden. Laat $x_1, x_2, \ldots x_n$ het signaal.
\begin{description}
\item[Zero-padding] $x' = 0, \ldots, 0| x_1, x_2, \ldots, x_n| 0, \ldots, 0$. Het gevolg van deze uitbreiding is dat het signaal niet langer continu hoeft te zijn op de randen;
\item[Constant padding] $x' = x_1, \ldots, x_1| x_1, x_2, \ldots, x_n| x_n, \ldots, x_n$. Het gevolg is nu dat het signaal geen continue afgeleide meer hoeft te hebben;
\item[Symmetric padding] $x' = x_n, \ldots, x_1| x_1, x_2, \ldots, x_n| x_n, \ldots, x_1$. Het gevolg is nu dat het signaal geen continue afgeleide meer hoeft te hebben;
\item[Periodic padding] $x' = x_1, \ldots, x_n| x_1, x_2, \ldots, x_n| x_1, \ldots, x_n$. Het nieuwe signaal hoeft wederom niet continu te worden.
\end{description}
Wij hebben ervoor gekozen om signalen uit te breiden door middel van zero-padding.

\section{Python?}
Voor de implementatie van de Fourier-transformatie is de taal Python gebruikt,
enkele redenen hiervoor waren:
\begin{itemize}
\item Voorzieningen om beeld en geluid te laden m.b.v. het \emph{scipy} pakket.
  Dit pakket liet ons bijvoorbeeld toe om beelden te laden als matrix van kleurwaarden en deze weer op te slaan
  nadat we deze gereconstrueerd hadden. Zo hoefden we ons niet te bekommeren om andere beeldcompressie implementaties.
\item Duidelijke relatie van wiskunde naar code. Python heeft een syntax die een wiskundige manier van denken en werken
  ondersteunt, in tegenstelling tot meer declaratieve talen zoals \emph{C} of object-georienteerde talen zoals \emph{Java}.
\item Goede abstractie van onderliggende processen. Python is een geinterpreteerde taal, dit betekent in concreto
  dat onze programma's draaien op een platform dat de allocatie van geheugen en rekenkracht. Dit vergemakkelijkt
  de implementatie en zorgt dat er makkelijk veranderingen zijn aan tee brengen in de code zonder het programma te crashen.
\end{itemize}
Het enige nadeel dat deze keuze teweeg heeft gebracht is dat de snelheid van al onze algoritmes tegenvalt
omdat we ons niet bezighouden met kleine optimalisaties en vertrouwen op de Python \emph{interpreter}.
