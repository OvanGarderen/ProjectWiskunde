\chapter{Basisbegrippen}
In dit verslag zullen een aantal termen worden ge\"introduceerd die wellicht niet bekend zijn. De eerste en meest belangrijke notie is dat wij \emph{signalen} analyseren. Een signaal is door \cite{signal} gedefinieerd als
\begin{quote}
Een signaal een functie die informatie over de kenmerken of het gedrag van een of ander fenomeen overdraagt.
\end{quote}

Enkele voorbeelden van een signaal zijn:
\begin{description}
	\item[Geluid] Geluid is de vibratie van een medium (zoals lucht) en een geluidssignaal associeert een bepaalde druk met elk moment in de tijd (en mogelijk op elk punt in de ruimte). Geluid wordt door een microfoon omgezet naar een elektrisch signaal welke weer ge\emph{sampled} kan worden tot een discrete lijst waardes in de tijd. Hiermee is geluid een eendimensionaal signaal.
	\item[Afbeeldingen] Een afbeelding bestaat uit een helderheidssignaal als functie van twee dimensies. Een afbeelding kan bestaan uit een continu domein, zoals bij een schilderij of een analoge foto, of een discreet raster zoals op de computer. Een kleurenafbeelding bestaat meestal uit drie kanalen, een voor de helderheid van elke primaire kleur.
	\item[Video] Een video is een lijst van afbeeldingen en een punt in een video wordt op deze manier gekarakteriseerd door een punt in de tijd samen met een punt in het vlak. Bewegend beeld is hiermee een driedimensionaal signaal met een al dan niet discreet domein.
\end{description}

In het vervolg zullen we de termen `signaal' en `functie' door elkaar gebruiken, tenzij anders aangegeven. Tijdens het project hebben we elk van deze drie voorbeelden bekeken, hoewel de twee- en driedimensionale signalen in ons verslag onze focus zullen krijgen.

\section{Implementatie}
\subsection{Signaaluitbreiding}
\label{signaal}
Beide algoritmes die we zullen behandelen kunnen enkel omgaan met signalen die een tweemacht lang zijn. Om te zorgen dat een willekeurig signaal ook getransformeerd kan worden, moet het dus uitgebreid worden voorbij zijn definitiegebied. De meeste bronnen onderscheiden de volgende manieren om het signaal uit te breiden.\cite{mallat,pywt} Laat $x_1, x_2, \ldots x_n$ het signaal.

Er zijn twee types die grote sprongen in het signaal kunnen veroorzaken (de discrete variant van een \emph{discontinu\"iteit}).
\begin{description}
\item[Zero-padding] $x' = 0, \ldots, 0| x_1, x_2, \ldots, x_n| 0, \ldots, 0$;
\item[Periodic padding] $x' = x_1, \ldots, x_n| x_1, x_2, \ldots, x_n| x_1, \ldots, x_n$.
\end{description}
Daarnaast zijn er nog twee types die een niet-vloeiende overgang kunnen veroorzaken (de discrete variant van een \emph{discontinue afgeleide}).
\begin{description}
\item[Constant padding] $x' = x_1, \ldots, x_1| x_1, x_2, \ldots, x_n| x_n, \ldots, x_n$;
\item[Symmetric padding] $x' = x_n, \ldots, x_1| x_1, x_2, \ldots, x_n| x_n, \ldots, x_1$.
\end{description}

De keuze van de \emph{signal extension mode} kan gevolgen hebben voor de mogelijkheid tot compressie op de rand. Verder in het verslag (zie stelling \ref{daling_fourier} en sectie \ref{daling_wavelets}) wordt duidelijk dat de functie $f$ moet voldoen aan bepaalde continu\"iteitseisen. Wanneer hier niet aan wordt voldaan, is het gevolg meestal dat compressie slecht mogelijk is.

\subsection{Gebruik van Python}
Voor de implementatie van de Fourier-transformatie is de taal Python gebruikt,
enkele redenen hiervoor waren:
\begin{itemize}
\item Voorzieningen om beeld en geluid te laden m.b.v. het \emph{scipy} pakket.
  Dit pakket liet ons bijvoorbeeld toe om beelden te laden als matrix van kleurwaarden en deze weer op te slaan
  nadat we deze gereconstrueerd hadden. Zo hoefden we ons niet te bekommeren om andere beeldcompressie implementaties.
\item Duidelijke relatie van wiskunde naar code. Python heeft een syntax die een wiskundige manier van denken en werken
  ondersteunt, in tegenstelling tot meer declaratieve talen zoals \emph{C} of object-georienteerde talen zoals \emph{Java}.
\item Goede abstractie van onderliggende processen. Python is een geinterpreteerde taal, dit betekent in concreto
  dat onze programma's draaien op een platform dat de allocatie van geheugen en rekenkracht. Dit vergemakkelijkt
  de implementatie en zorgt dat er makkelijk veranderingen zijn aan tee brengen in de code zonder het programma te crashen.
\end{itemize}
Het enige nadeel dat deze keuze teweeg heeft gebracht is dat de snelheid van al onze algoritmes tegenvalt
omdat we ons niet bezighouden met kleine optimalisaties en vertrouwen op de Python \emph{interpreter}.

\section{Wiskunde}

\subsection{Notatie}
Analoog aan de notatie $f(x)$ die we in het algemeen voor een functie gebruiken, voeren we de blokhaaknotatie $f[x]$ in die duidt op een discrete functie
\[
f:A\subset \Z\to \R \text{ of } f:A\subset \Z\to \C.  
\]
Vaak zullen we voor $A$ het interval $\{1,\ldots,n\}$ nemen, 
dan is $f$ gelijk aan een vector in $\R^n$ of $\C^n$.
In het bijzonder duiden we met deze notatie dus de entries van een vector aan.

We zullen de notatie ook uitbreiden naar meer dimensies door te schrijven
\begin{equation*}
\begin{split}
f: A_1\times \cdots \times A_n\subset \Z^n \to& K \\
       (x_1,\ldots,x_n) \mapsto& f[x_1,\ldots,x_n],
\end{split}
\end{equation*}
Uit zo'n $m$-dimensionale functie $f$ kunnen we vervolgens op een natuurlijke manier een $m-k$-dimensionale
functie construeren door $k$ co\"ordinaten vast te nemen:
\begin{equation*}
\begin{split}
f\largediv_{x_{i_1}=a_{i_1},\ldots,x_{i_k}=a_{i_k}}: A_{i_{k+1}}\times\cdots\times A_{i_{m}} \to& K \\
(a_{i_{k+1}},\ldots,a_{i_{m}}) \mapsto& f[a_1,\ldots,a_m]
\end{split}
\end{equation*}
Hier zijn $i_1$'de tot en met de $i_k$'de co\"ordinaat vast genomen. Voor een matrix kan deze functie
bijvoorbeeld gezien worden als een rij of een kolom, in dat voorbeeld geeft $i_1$ aan of de rij of kolom
vast staat en geeft $a_{i_1}$ aan welke rij respectievelijk kolom bekeken wordt.

\subsection{Complexiteit}

Aangezien er algoritmes behandeld worden in het verslag willen we hiervan de tijdscomplexiteit bepalen.
Deze eigenschap bepaalt namelijk hoe de tijd die het een machine kost oploopt met de grootte van de input.
We voeren daarom $o$, $\O$ en $\theta$ als notatie in.
\begin{equation*}
\begin{array}{cccccccc}
  f \in \O(g)     &\Leftrightarrow& \exists c     \,:&\exists x_0  \,:&\, 
  \forall x>x_0 \quad&& |f(x)| &\leq c|g(x)|  \\
  f \in o(g)      &\Leftrightarrow& \forall c     \,:&\exists x_0  \,:&\, 
  \forall x>x_0 \quad&& |f(x)| &\leq c |g(x)| \\ 
  f \in \theta(g) &\Leftrightarrow& \exists c_1,c_2\,:&\exists x_0  \,:&\, 
  \forall x>x_0 \quad& c_1|g(x)| \leq & |f(x)| &\leq c_2|g(x)|  \\
  f \simeq g & \Leftrightarrow& \exists c_1,c_2\,:& \,&\, 
  \forall x \quad& c_1|g(x)| \leq & |f(x)| &\leq c_2|g(x)| 

\end{array}
\end{equation*}
Merk op dat $o$ een \emph{sterker} begrip is dan $\O$: als $f \in o(g)$ dan $f \in \O(g)$. Verder betekent $f \in \theta(g)$ dat $f$ gaat precies even snel omhoog als $g$. Ook geldt dat $f\simeq g \implies f\in\theta(g)$.

We zullen in de praktijk algoritmes $f$ bekijken die een 1,2 of 3 dimensionale lijst data als input hebben.
We zijn dan ge\"interesseerd in de tijdscomplexiteit in termen van de grootte van bijvoorbeeld een $N\times N$ 
afbeelding, dus is $f$ een functie van $N$.

\subsection{Ruimtes}
Een belangrijk lemma dat we zullen gebruiken is het volgende lemma van Parseval.
\begin{lemm}[Parsevalgelijkheid\cite{parseval}]
  \label{parseval}
  Laat $f$ een functie in $L^2(K)$ met $K \subset \C^n$ of $K\subset\R^n$, die geschreven kan worden in een aftelbare 
  orthonormale basis $\mathcal{B}=\{g_m\}$ dan geldt
  \[
  \|f\|^2 = \sum_{g_m\in\mathcal{B}} | \langle f, g_m \rangle |^2.
  \]
\end{lemm}

