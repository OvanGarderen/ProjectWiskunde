\chapter{Basisbegrippen}

\section{Signaaluitbreiding}
\label{signaal}
Beide algoritmes kunnen enkel omgaan met signalen die een tweemacht lang zijn. Om te zorgen dat een willekeurig signaal ook getransformeerd kan worden, moet het dus uitgebreid worden voorbij zijn definitiegebied. De meeste bronnen onderscheiden de volgende manieren om het signaal uit te breiden. Laat $x_1, x_2, \ldots x_n$ het signaal.
\begin{description}
\item[Zero-padding] $x' = 0, \ldots, 0| x_1, x_2, \ldots, x_n| 0, \ldots, 0$. Het gevolg van deze uitbreiding is dat het signaal niet langer continu hoeft te zijn op de randen;
\item[Constant padding] $x' = x_1, \ldots, x_1| x_1, x_2, \ldots, x_n| x_n, \ldots, x_n$. Het gevolg is nu dat het signaal geen continue afgeleide meer hoeft te hebben;
\item[Symmetric padding] $x' = x_n, \ldots, x_1| x_1, x_2, \ldots, x_n| x_n, \ldots, x_1$. Het gevolg is nu dat het signaal geen continue afgeleide meer hoeft te hebben;
\item[Periodic padding] $x' = x_1, \ldots, x_n| x_1, x_2, \ldots, x_n| x_1, \ldots, x_n$. Het nieuwe signaal hoeft wederom niet continu te worden.
\end{description}
Wij hebben ervoor gekozen om signalen uit te breiden door middel van zero-padding.

\section{Python?}
Voor de implementatie van de Fourier-transformatie is de taal Python gebruikt,
enkele redenen hiervoor waren:
\begin{itemize}
\item Voorzieningen om beeld en geluid te laden m.b.v. het \emph{scipy} pakket.
  Dit pakket liet ons bijvoorbeeld toe om beelden te laden als matrix van kleurwaarden en deze weer op te slaan
  nadat we deze gereconstrueerd hadden. Zo hoefden we ons niet te bekommeren om andere beeldcompressie implementaties.
\item Duidelijke relatie van wiskunde naar code. Python heeft een syntax die een wiskundige manier van denken en werken
  ondersteunt, in tegenstelling tot meer declaratieve talen zoals \emph{C} of object-georienteerde talen zoals \emph{Java}.
\item Goede abstractie van onderliggende processen. Python is een geinterpreteerde taal, dit betekent in concreto
  dat onze programma's draaien op een platform dat de allocatie van geheugen en rekenkracht. Dit vergemakkelijkt
  de implementatie en zorgt dat er makkelijk veranderingen zijn aan tee brengen in de code zonder het programma te crashen.
\end{itemize}
Het enige nadeel dat deze keuze teweeg heeft gebracht is dat de snelheid van al onze algoritmes tegenvalt
omdat we ons niet bezighouden met kleine optimalisaties en vertrouwen op de Python \emph{interpreter}.

\section{Notatie}

De blokhaaknotatie $f[x]\in K$ duidt op een discrete functie $A\subset \Z\to K$ met $K$ een willekeurige ruimte.
Als $A$ bovendien eindig is, dan is $f$ ook te karakteriseren aan de hand van zijn beeld, een vector in $K^{N}$.
In het bijzonder is deze notatie dus een manier om een vector aan te duiden.
Evenzo kunnen we de notatie uitbreiden naar meer dimensies door te schrijven
$f[x_1,\ldots,x_n] : A_1\times \cdots \times A_n\subset \Z^n \to K$, waarbij de $A_i$'s meestal eindige intervallen zijn. 


\section{Complexiteit}

Aangezien er enkele algoritmes behandeld worden in het verslag willen we hiervan de tijdscomplexiteit bepalen.
Deze eigenschap bepaalt namelijk hoe de tijd die het een machine kost oploopt met de grootte van de input.
We voeren daarom zowel \emph{Big O} als \emph{theta} notatie in.
\begin{eqnarray}
  f \in \O(g)     \Leftrightarrow \exists x_0,c \,:&\,\forall x>x_0 \quad|f(x)| \leq c|g(x)|  \\
  f \in \theta(g) \Leftrightarrow \exists x_0,k_1,k_2 \,:&\,\forall x>x_0 \quad k_1|g(x)| \leq |f(x)|\leq k_2|g(x)|
\end{eqnarray}
We zullen in de praktijk algoritmes $f$ bekijken die een 1,2 of 3 dimensionale lijst data als input hebben.
We zijn dan ge\"interesseerd in de tijdscomplexiteit in termen van de grootte van bijvoorbeeld een $N\times N$ 
afbeelding, dus is $f$ een functie van $N$.
